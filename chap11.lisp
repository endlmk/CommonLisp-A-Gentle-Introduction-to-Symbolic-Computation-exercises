(defun it-member (target x)
  (dolist (e x)
    (if (equal e target) (return t))))

(defun it-assoc (target x)
  (dolist (e x)
    (if (equal (first e) target) (return (second e)))))

(defun check-all-odd (x)
  (cond ((null x) t)
	((evenp (first x)) (format t "~&Checking ~S..." (first x)) nil)
	(t (format t "~&Checking ~S..." (first x)) (check-all-odd (rest x)))))

(defun it-length (x)
  (let ((len 0))
    (dolist (e x len)
      (setf len (+ 1 len)))))

(defun it-nth (n x)
  (let ((cnt 0))
    (dolist (e x)
      (if (equal cnt n) (return e))
      (setf cnt (+ cnt 1)))))

(defun it-union (x y)
  (let ((prod x))
    (dolist (e y prod)
      (unless (member e x)
	(push e prod)))))

(defun it-reverse (x)
  (let ((result nil))
    (dolist (e x result)
      (push e result))))

(defun check-all-odd (x)
  (do ((w x (cdr w)))
      ((null w) t)
    (format t "~&Checking ~S..." (first w))
    (if (not (oddp (first w))) (return nil))))

(defun launch (n)
  (dotimes (cnt n (format t "Blast off!"))
    (format t "~S..." (- n cnt))))

(defun find-largest-do (list-of-numbers)
  (do* ((x list-of-numbers (rest x))
	(e (first x) (first x))
	(result (first list-of-numbers)))
       ((null x) result)
    (when (> e result)
      (setf result e))))

(defun power-of-2-do (n)
  (do ((cnt n (- cnt 1))
       (result 1 (+ result result)))
      ((zerop cnt) result)))

(defun first-non-integer (x)
  (dolist (e x nil)
    (if (not (integerp e)) (return e))))

(defun complement-base (x)
  (second (assoc x '((A T)
		     (G C)
		     (T A)
		     (C G)))))

(defun complement-strand (x)
  (mapcar #'(lambda (e) (complement-base e)) x))

(defun make-double (x)
  (mapcar #'(lambda (e) (list e (complement-base e))) x))

(defun count-bases (x)
  (let ((cnt_a 0)
	(cnt_t 0)
	(cnt_g 0)
	(cnt_c 0))
    (labels ((count-elem (e)
	       (cond ((equal e 'a) (incf cnt_a))
		     ((equal e 't) (incf cnt_t))
		     ((equal e 'g) (incf cnt_g))
		     ((equal e 'c) (incf cnt_c)))))
      (dolist (e x (list (list 'a cnt_a)
			 (list 't cnt_t)
			 (list 'g cnt_g)
			 (list 'c cnt_c)))
	(cond ((atom e) (count-elem e))
	      (t (count-elem (first e))
		 (count-elem (second e))))))))

(defun prefixp (target test)
  (cond ((null target) t)
	((null test) nil)
	((equal (first target) (first test)) (prefixp (rest target) (rest test)))
	(t nil)))

(defun appearsp (target test)
  (cond ((null test) nil)
	((prefixp target test) t)
	(t (appearsp target (rest test)))))

(defun coverp (target test)
  (cond ((null test) t)
	((null target) nil)
	((prefixp target test) (coverp target (subseq test (length target))))
	(t nil)))
    
(defun prefix (n x)
  (subseq x 0 n))

(defun kernel-helper (x n)
  (cond ((<= (length x) n) x)
	((coverp (prefix n x) x) (prefix n x))
	(t (kernel-helper x (+ n 1)))))

(defun kernel (x)
  (kernel-helper x 1))

(defun draw-dna (x)
  (dotimes (n (length x))
    (format t "-----"))
  (format t "~%")
  (dotimes (n (length x))
    (format t "  !  "))
  (format t "~%")
  (dolist (e x)
    (format t "  ~S  " e))
  (format t "~%")
  (dotimes (n 2)
    (dotimes (n (length x))
      (format t "  .  "))
    (format t "~%"))
  (dolist (e (complement-strand x))
    (format t "  ~S  " e))
  (format t "~%")
  (dotimes (n (length x))
    (format t "  !  "))
  (format t "~%")
  (dotimes (n (length x))
    (format t "-----"))
  (format t "~%"))
  
